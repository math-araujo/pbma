#include <algorithm>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <polyscope/point_cloud.h>
#include <polyscope/surface_mesh.h>
#include <vector>

#include "application.hpp"
#include "geometry.hpp"
#include "implot.h"
#include "io.hpp"
#include "shapes/uv_sphere.hpp"

class TemplateApplication : public physcope::Application
{
public:
    // Note that Polyscope structures should NOT be created or
    // initialized inside the constructor. They should be created
    // and accessed only inside initialize() and pre_draw().
    TemplateApplication() = default;
    ~TemplateApplication() override = default;

    /*
    Polyscope-related structures are meant to be created inside
    initialize member-function.
    */
    void initialize() override
    {
        // OBJ file can be read directly from file, if you wish so
        // auto triangle_mesh{physcope::read_triangle_mesh_obj("assets/suzanne.obj", true)};

        // ... Or you can store the OBJ file on a string_view variable and use it instead
        auto triangle_mesh{physcope::read_triangle_mesh_obj(physcope::shapes::uv_sphere, "", true)};
        mesh = polyscope::registerSurfaceMesh("mesh", triangle_mesh.vertices, triangle_mesh.indices);
    }

    /*
    Update a displacement variable based on a simple logic.
    This variable can then be used at pre_draw() member function
    to update the render-related Polyscope structures
    */
    void physics_update() override
    {
        if (is_animating())
        {
            if (sign > 0 && displacement > 4.0f)
            {
                sign = -1;
            }
            else if (sign < 0 && displacement < 1.0f)
            {
                sign = 1;
            }

            displacement += (sign)*0.01f;
            positions.emplace_back(displacement);
        }
    }

    /*
    Update Polyscope structures fields (e.g. position) based on the output
    generated by the physics_update member function.
    */
    void pre_draw() override
    {
        // Update point cloud
        points.clear();
        for (int i = 0; i < number_of_points; ++i)
        {
            points.emplace_back(
                glm::vec3{polyscope::randomUnit(), polyscope::randomUnit() + 1.5f, polyscope::randomUnit()});
        }
        // This creates a new point cloud every iteration, which is wasteful; this was done
        // only to access the performance impact of such usage.
        point_cloud = polyscope::registerPointCloud("Sample Point Cloud", points);

        if (is_animating())
        {
            point_cloud->setTransform(glm::translate(glm::mat4{1.0f}, glm::vec3{0.0f, displacement, 0.0f}));
            mesh->setTransform(glm::translate(glm::mat4{1.0f}, glm::vec3{displacement, 0.0f, 0.0f}));
        }

        const std::size_t time_samples{std::min(positions.size(), std::size_t{10'000})};
        if (ImPlot::BeginPlot("Position over Time"))
        {
            ImPlot::SetupAxesLimits(0, std::max(time_samples, std::size_t{1'000}), 0, 4);
            ImPlot::PlotLine("Position", positions.data(), time_samples);
            ImPlot::EndPlot();
        }
    }

private:
    const int number_of_points{10000};
    polyscope::PointCloud* point_cloud{nullptr};
    polyscope::SurfaceMesh* mesh{nullptr};
    std::vector<glm::vec3> points;
    std::vector<float> positions;
    float displacement{0.0f};
    int sign{1};
};

int main()
{
    TemplateApplication app{};
    app.run();
    return 0;
}